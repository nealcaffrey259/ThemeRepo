-- Auto Updater from https://github.com/hexarobi/stand-lua-auto-updater
local status, auto_updater = pcall(require, 'auto-updater')
if not status then
  local auto_update_complete = nil
  util.toast('Installing auto-updater...', TOAST_ALL)
  async_http.init('raw.githubusercontent.com', '/hexarobi/stand-lua-auto-updater/main/auto-updater.lua',
      function(result, headers, status_code)
        local function parse_auto_update_result(result, headers, status_code)
          local error_prefix = 'Error downloading auto-updater: '
          if status_code ~= 200 then
            util.toast(error_prefix .. status_code, TOAST_ALL)
            return false
          end
          if not result or result == '' then
            util.toast(error_prefix .. 'Found empty file.', TOAST_ALL)
            return false
          end
          filesystem.mkdir(filesystem.scripts_dir() .. 'lib')
          local file = io.open(filesystem.scripts_dir() .. 'lib\\auto-updater.lua', 'wb')
          if file == nil then
            util.toast(error_prefix .. 'Could not open file for writing.', TOAST_ALL)
            return false
          end
          file:write(result)
          file:close()
          util.toast('Successfully installed auto-updater lib', TOAST_ALL)
          return true
        end
        auto_update_complete = parse_auto_update_result(result, headers, status_code)
      end, function()
        util.toast('Error downloading auto-updater lib. Update failed to download.', TOAST_ALL)
      end)
  async_http.dispatch()
  local i = 1
  while (auto_update_complete == nil and i < 40) do
    util.yield(250)
    i = i + 1
  end
  if auto_update_complete == nil then
    error('Error downloading auto-updater lib. HTTP Request timeout')
  end
  auto_updater = require('auto-updater')
end
if auto_updater == true then
  error('Invalid auto-updater lib. Please delete your Stand/Lua Scripts/lib/auto-updater.lua and try again')
end

local async_http, filesystem, io, menu, util = async_http, filesystem, io, menu, util
local og_toast = util.toast
util.toast = function(message)
	og_toast('[ThemeRepo] ' .. message)
end

local root = menu.my_root()

local inspect = require 'lib/inspect'
local function log(what)
	util.log(inspect(what))
end

local function get_github_auth() 
	if file := io.open(filesystem.resources_dir() .. 'ThemeRepo\\.github', 'r') then
		local token = file:read('a')
		file:close()
		return token:startswith('ghp_') and token:len() == 40 and token
	end
	return nil
end

local function fetch(host, path, callback)
	local finished = false
	async_http.init(host, path, function(body, headers, status_code)
		if status_code == 403 then
			local expire_at = os.date('%d-%m %H:%M', headers['X-Ratelimit-Reset'])
			for i = 1, 5 do
				util.toast($'You are currently being ratelimited by GitHub.\nThis will expire at {expire_at}.')
			end
			util.stop_script()
		elseif status_code == 404 then
			goto continue
		end

		pcall(callback, body, headers, status_code)

		::continue::
		finished = true
	end, function()
		util.toast($'Request to {host}{path} failed to send.')
		finished = true
	end)
	if token := get_github_auth() then
		async_http.add_header('Authorization', 'Bearer ' .. token)
	end
	async_http.dispatch()

	repeat
		util.yield()
	until finished
end

local function make_request(path, callback)
	fetch('https://api.github.com', '/repos/stagnate6628/stand-themerepo/contents/' .. path, function(body, headers, status_code) 
		pcall(callback, body, headers, status_code)
	end)
end

local function write_file(path, body)
	if not filesystem.is_dir(path:match('^(.+)[\\/]')) then
		filesystem.mkdirs(path:match('^(.+)[\\/]'))
	end

	local file = io.open(path, 'wb')
	file:write(body)
	file:close()
end

local function download_file(host, path, file_path, callback)
	fetch(host, path, function(body, headers, status_code)
		if type(file_path) == 'string' then
			file_path = {file_path}
		end

		for file_path as path do
			write_file(path, body)
		end
	end)
end

local function empty_dir(dir)
  for io.listdir(dir) as path do
  	if filesystem.is_regular_file(path) then
  		io.remove(path)
  		continue
  	end

  	empty_dir(path)
  	io.remove(path)
  end
end

local stand_dir = filesystem.stand_dir()

local header_dir = stand_dir .. 'Headers\\Custom Header\\'
local theme_dir = stand_dir .. 'Theme\\'
local custom_dir = theme_dir .. 'Custom\\'
local tabs_dir = theme_dir .. 'Tabs\\'

local resources_dir = filesystem.resources_dir() .. 'ThemeRepo\\'
local themes_dir = resources_dir .. 'Themes\\'
local headers_dir = resources_dir .. 'Headers\\'
local backups_dir = resources_dir .. 'Backups\\'

do 
	menu.ref_by_path('Stand>Lua Scripts>Settings>Presets>Developer'):trigger()

	for { themes_dir, headers_dir } as path do
		if not filesystem.is_dir(path) then 
			filesystem.mkdir(path)
		end	
	end

	local function get_all_files(path, files)
		files ??= {}

		make_request(path, function(body, headers, status_code)
			body = soup.json.decode(body)

			for body as file do
				if file.type == 'file' then
					table.insert(files, file.path)
					continue
				end

				get_all_files(file.path, files)
			end
		end)

		return files
	end

	local function get_local_path(path)
		local last_dir = path:match('.*/([^/]+)/[^/]+$')
		local file_name, ext = path:match(".+/([^/]+)%.([^%.]+)$")

		local return_dir = nil

		if last_dir == 'Custom Header' then
			return_dir = header_dir
		elseif last_dir == 'Theme' then
			return_dir = theme_dir
		elseif last_dir == 'Tabs' then
			return_dir = tabs_dir
		elseif last_dir == 'Custom' then 
			return_dir = custom_dir
		elseif last_dir == 'Lua Scripts' then
			return_dir = filesystem.scripts_dir()
		else
			if ext == 'txt' then
				return_dir = stand_dir .. 'Profiles\\'
			end
		end

		if return_dir then
			return return_dir .. file_name .. '.' .. ext
		end
		return nil
	end
	
	local function load_theme(theme_name)
		util.toast($'Loading {theme_name}...')

		menu.ref_by_path('Stand>Settings>Appearance>Textures>Reload Textures'):trigger()
		menu.ref_by_path('Stand>Settings>Appearance>Font & Text>Reload Font'):trigger()

		util.yield(100)

		menu.ref_by_path('Stand>Profiles'):trigger()
		menu.ref_by_path('Stand'):trigger()

		menu.ref_by_path('Stand>Lua Scripts'):trigger()
		menu.ref_by_path('Stand'):trigger()

		local ref = menu.ref_by_path('Stand>Profiles>' .. theme_name)
		if not ref:isValid() then
			util.toast('Failed to load the theme.')
			return
		end

		ref:refByRelPath('Active'):trigger()
		ref:refByRelPath('Load'):trigger()
		util.yield()
		ref:refByRelPath('Load'):trigger()
	end

	local function download_theme(theme_name)
		util.toast($'Downloading {theme_name}...')

		empty_dir(header_dir)
		empty_dir(theme_dir)

		local files
		local manifest = themes_dir .. theme_name .. '\\.manifest'

		if not filesystem.is_regular_file(manifest) then
			files = get_all_files('Themes/' .. theme_name)
			write_file(manifest, table.concat(files, '\n'))
		else
			local file = io.open(manifest, 'r')
			files = file:read('*a'):split('\n')
			file:close()
		end

		local i = 0
		for files as path do
			local path_ = resources_dir .. path:gsub('/', '\\')

			if not filesystem.is_regular_file(path_) then
				download_file(
					'https://raw.githubusercontent.com',
					'/stagnate6628/stand-themerepo/main/' .. path,
					path_
				)
			end

			if stand_path := get_local_path(path) then
				io.copyto(path_, stand_path) 
			end

			i += 1
		end

		repeat
			util.yield()
		until i == #files

		load_theme(theme_name)
	end

	local function download_header(header_name) 
	end

	for i, file in { 'themes.txt', 'headers.txt' } do
		local path = resources_dir .. file
		if not filesystem.is_regular_file(path) then
			download_file(
				'https://raw.githubusercontent.com', 
				'/stagnate6628/stand-themerepo/main/' .. file,
				path
			)
		end

		local f = io.open(path, 'r')
		local body = f:read('*a'):split('\n')
		f:close()

		local fn = i == 1 ? download_theme : download_header
		root:list_action(file, {}, '', body, function(index, menu_name, click_type) 
			fn(menu_name)
		end)
	end
end

local config = root:list('Configuration', {}, '')
config:list_action('Reset', {}, '', { 'Theme', 'Font', 'Header', 'Appearance' }, function(index, menu_name, click_type) end)