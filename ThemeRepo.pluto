-- Auto Updater from https://github.com/hexarobi/stand-lua-auto-updater
local status, auto_updater = pcall(require, 'auto-updater')
if not status then
	local auto_update_complete = nil
	util.toast('Installing auto-updater...', TOAST_ALL)
	async_http.init('raw.githubusercontent.com', '/hexarobi/stand-lua-auto-updater/main/auto-updater.lua',
		function(result, headers, status_code)
		local function parse_auto_update_result(result, headers, status_code)
			local error_prefix = 'Error downloading auto-updater: '
			if status_code ~= 200 then
				util.toast(error_prefix .. status_code, TOAST_ALL)
				return false
			end
			if not result or result == '' then
				util.toast(error_prefix .. 'Found empty file.', TOAST_ALL)
				return false
			end
			filesystem.mkdir(filesystem.scripts_dir() .. 'lib')
			local file = io.open(filesystem.scripts_dir() .. 'lib\\auto-updater.lua', 'wb')
			if file == nil then
				util.toast(error_prefix .. 'Could not open file for writing.', TOAST_ALL)
				return false
			end
			file:write(result)
			file:close()
			util.toast('Successfully installed auto-updater lib', TOAST_ALL)
			return true
		end
		auto_update_complete = parse_auto_update_result(result, headers, status_code)
	end, function()
		util.toast('Error downloading auto-updater lib. Update failed to download.', TOAST_ALL)
	end)
	async_http.dispatch()
	local i = 1
	while (auto_update_complete == nil and i < 40) do
		util.yield(250)
		i = i + 1
	end
	if auto_update_complete == nil then
		error('Error downloading auto-updater lib. HTTP Request timeout')
	end
	auto_updater = require('auto-updater')
end
if auto_updater == true then
	error('Invalid auto-updater lib. Please delete your Stand/Lua Scripts/lib/auto-updater.lua and try again')
end

local async_http, filesystem, io, menu, util = async_http, filesystem, io, menu, util
local has_internet_access = async_http.have_access() -- afaik this cant be changed until stop

local root = menu.my_root()
local SCRIPT_VERSION = '1.5.0'

if not SCRIPT_SILENT_START and math.random() > 0.85 then
	util.toast('Please make backups as needed. This will not be done for you.')
end

local function get_github_auth()
	if file := io.open(filesystem.resources_dir() .. 'ThemeRepo\\.github', 'r') then
		local token = file:read('a')
		file:close()
		return token:startswith('ghp_') and token:len() == 40 and token
	end
	return nil
end

local function fetch(host, path, callback)
	if not has_internet_access then
		return
	end

	local finished = false
	async_http.init(host, path, function(body, headers, status_code)
		if status_code == 403 then
			local toast_msg = 'You are currently being ratelimited by Github.'
			if headers['X-Ratelimit-Reset'] then
				local expire_at = os.date('%d-%m %H:%M', headers['X-Ratelimit-Reset'])
				toast_msg ..= $'\nThis will expire at {expire_at}.'
			end
			for i = 1, 5 do
				util.toast(toast_msg)
			end
			util.stop_script()
		elseif status_code == 404 then
			goto continue
		end

		pcall(callback, body, headers, status_code)

		::continue::
		finished = true
	end, function()
		util.toast($'Request to {host}{path} failed to send.', TOAST_ALL)
		finished = true
	end)
	if token := get_github_auth() then
		async_http.add_header('Authorization', $'Bearer {token}')
	end
	async_http.dispatch()

	repeat
		util.yield()
	until finished
end

local function make_request(path, callback)
	fetch('https://api.github.com', $'/repos/stagnate6628/stand-themerepo/contents/{path}', function(body, headers, status_code) 
		pcall(callback, body, headers, status_code)
	end)
end

local function read_file(path)
	local file = io.open(path, 'r')
	local content = file:read('*a')
	file:close()
	return content
end

local function write_file(path, body)
	if not filesystem.is_dir(path:match('^(.+)[\\/]')) then
		filesystem.mkdirs(path:match('^(.+)[\\/]'))
	end

	local file = io.open(path, 'wb')
	file:write(body)
	file:close()
end

local function download_file(host, path, file_path, callback)
	fetch(host, path, function(body, headers, status_code)
		if type(file_path) == 'string' then
			file_path = {file_path}
		end

		for file_path as path do
			write_file(path, body)
		end
	end)
end

local function empty_dir(dir)
	-- recurse
	io.remove(dir, true)

	local i = 0

	-- dir should not exist atp
	repeat
		util.yield(250)
		i += 1
	until not filesystem.is_dir(dir) or i == 10

	if i == 30 then
		local count = #filesystem.list_files(dir, true)
		util.toast($'Failed to empty {dir} in time, total files remaining: {count}', TOAST_ALL)
	end
end

local stand_dir = filesystem.stand_dir()
local stand_ref = menu.ref_by_path('Stand')

local header_dir = stand_dir .. 'Headers\\Custom Header\\'
local theme_dir = stand_dir .. 'Theme\\'
local custom_dir = theme_dir .. 'Custom\\'
local tabs_dir = theme_dir .. 'Tabs\\'

local resources_dir = filesystem.resources_dir() .. 'ThemeRepo\\'
local themes_dir = resources_dir .. 'Themes\\'
local headers_dir = resources_dir .. 'Headers\\'

local display_download_status = true

local apply_to_active_profile = false

local is_downloading = false

local function reload_textures()
	menu.ref_by_path('Stand>Settings>Appearance>Textures>Reload Textures'):trigger()
end

local function reload_font()
	menu.ref_by_path('Stand>Settings>Appearance>Font & Text>Reload Font'):trigger()
end

local function header_hide()
	menu.ref_by_path('Stand>Settings>Appearance>Header>Header>Be Gone'):trigger()
end

local function header_custom()
	menu.ref_by_path('Stand>Settings>Appearance>Header>Header>Custom'):trigger()
end

local function get_all_files(path, files = {})
	path ..= '?ref=refactor-downloader'
	make_request(path, function(body, headers, status_code)
		body = soup.json.decode(body)

		for body as file do
			if file.type == 'file' then
				table.insert(files, file.path)
				continue
			end

			get_all_files(file.path, files)
		end
	end)

	return files
end

local function get_manifest(path, type, menu_name)
	local files = {}
	path ..= $'{menu_name}\\.manifest.'

	if not filesystem.is_regular_file(path) then
		files = get_all_files($'{type}/{menu_name}')
		write_file(path, table.concat(files, '\n'))
	else
		local file = io.open(path, 'r')
		files = f:read('*a'):split('\n')
		file:close()
	end

	return files
end

local function load_theme(theme_name)
	util.toast($'Loading {theme_name}.', TOAST_ALL)

	reload_textures()
	reload_font()

	stand_ref:refByRelPath('Profiles'):trigger()
	util.yield(100)
	stand_ref:trigger()
	util.yield(100)
	stand_ref:refByRelPath('Profiles'):trigger()

	stand_ref:refByRelPath('Lua Scripts'):trigger()
	util.yield(100)
	stand_ref:trigger()
	util.yield(100)
	stand_ref:refByRelPath('Lua Scripts'):trigger()
	util.yield(100)

	local ref = menu.ref_by_path($'Stand>Profiles>{theme_name}')
	if not ref:isValid() then
		util.toast($'The profile for {theme_name} could not be found.', TOAST_ALL)
		return
	end

	if apply_to_active_profile then
  		local meta_state = util.read_colons_and_tabs_file($'{stand_dir}Meta State.txt')
		local active_profile = meta_state['Active Profile'] or 'Main'

		local path = $'{stand_dir}Profiles\\{theme_name}.txt'

		ref = menu.ref_by_path($'Stand>Profiles>{active_profile}')

		for k, v in util.read_colons_and_tabs_file(path) do
			if k:startswith('Stand>Settings>Appearance') or 
			   	k:startswith('Stand>Lua Scripts') or 
			  	k:startswith('Players>Settings>Tags') then

				local r = menu.ref_by_path($'{k}>{v}')
				if r:isValid() then
					r:trigger()
				else
					r = menu.ref_by_path(k)
					if r:isValid() then
						menu.trigger_command(r, v)
					end
				end
			end
			util.yield()
		end

		util.toast('Done! Make sure you save the profile if you want to keep its appearance.')
		return
	end

	ref:refByRelPath('Load'):trigger()
	ref:refByRelPath('Load'):trigger()

	ref:refByRelPath('Active'):trigger()
	util.yield(100)

	util.toast('Done!')
end

local function download_theme(theme_name)
	empty_dir(theme_dir)
	empty_dir(header_dir)

	header_hide()

	local files = get_manifest(themes_dir, 'Themes', theme_name)
	local i = 0

	if display_download_status then
		util.create_tick_handler(function()
			if i == #files then
				return false
			end
			util.draw_debug_text($'{theme_name}: {i}/' .. #files)
			return true
		end)
	end

	for files as file do
		i += 1

		local base_path = file:gsub('/', '\\')
		local local_path = base_path:gsub('Themes\\(.-)\\', '')
		local dir = local_path:match('^(.-)[\\/][^\\/]*$')
		local paths = {resources_dir .. base_path}

		-- this is kinda scuffed :|
		if dir then
			if dir == 'Interaction Header' then
				table.insert(paths, resources_dir .. base_path)
			else
				table.insert(paths, stand_dir .. local_path)
			end
		end

		if filesystem.is_regular_file(paths[1]) then
			if paths[2] then
				io.copyto(paths[1], paths[2])
			end
			continue
		end

		download_file(
			'https://raw.githubusercontent.com',
			$'/stagnate6628/stand-themerepo/refactor-downloader/{file}',
			paths
		)
	end

	load_theme(theme_name)
end

local function download_header(header_name)
	empty_dir(header_dir)

	header_hide()

	local files = get_manifest(headers_dir, 'Headers', header_name)
	local i = 0

	if display_download_status then
		util.create_tick_handler(function()
			if i == #files then
				return false
			end
			
			util.draw_debug_text($'{header_name}: {i}/' .. #files)
			return true
		end)
	end

	for files as file do
		i += 1
		
		local base_path = file:gsub('/', '\\')
		local paths = {resources_dir .. base_path}
		table.insert(paths, header_dir .. paths[1]:match('[^\\/]*$'))

		if filesystem.is_regular_file(paths[1]) and not filesystem.is_regular_file(paths[2]) then
			io.copyto(paths[1], paths[2])
			continue
		end

		download_file(
			'https://raw.githubusercontent.com',
			$'/stagnate6628/stand-themerepo/refactor-downloader/{file}',
			paths
		)
	end

	header_custom()
end

local all_children = {}

do
	for { 'Headers', 'Themes' } as v do
		local file_name = v:lower() .. '.txt'
		local path = resources_dir .. file_name

		if not filesystem.is_regular_file(path) then
			util.toast($'Downloading missing file ({file_name}).', TOAST_ALL)
			download_file(
				'https://raw.githubusercontent.com',
				$'/stagnate6628/stand-themerepo/main/{file_name}', path
			)
		end

		local f = io.open(path, 'r')
		local body = f:read('*a'):split('\n')
		f:close()

		local fn = v == 'Headers' ? download_header : download_theme
		local ref = root:list_action(v, {}, '', body, function(_, menu_name)
			if is_downloading then
				util.toast('It appears that a download is active. If that is not the case, then restart the script.')
				return
			end
			
			is_downloading = true
			
			util.toast($'Downloading {menu_name}.', TOAST_ALL)
			fn(menu_name)

			is_downloading = false
		end)

		for ref:getChildren() as child do
			table.insert(all_children, child)
		end
	end
end

local config_root = root:list('Configuration', {}, '')
config_root:divider('General')
config_root:toggle('Download Status', {}, 'Displays a counter using the "Info Text" system to show what is being downloaded and the file count.', function(s)
	display_download_status = s
end, display_download_status)

config_root:divider('Themes')
config_root:toggle('Apply To Active Profile', {}, 'Not guaranteed to apply properly. Reliability is a hit or miss.', function(s, click_type)
	apply_to_active_profile = s

	if apply_to_active_profile then
		util.toast('It may help to use a fresh profile or default appearance.')
	end
end, apply_to_active_profile)

config_root:divider('Utilities')

local search_root = config_root:list('Search', {}, '')
search_root:text_input('Query', {'themereposearch'}, '', function(input, click_type)
	if input != '' and table.contains({ 1, 4 }, click_type) != nil then
		if not search_root:isFocused() then
			search_root:trigger()
		end

		for search_root:getChildren() as child do
			if child:getType() == COMMAND_INPUT then
				continue
			end
			child:delete()
		end
		menu.collect_garbage()

		for all_children as child do
			if child.menu_name:lower():contains(input:lower()) then
				search_root:action(child.menu_name, {}, child:getParent().menu_name .. ' > ' .. child.menu_name, function()
					child:trigger()
				end)
			end
		end

		if #search_root:getChildren() == 1 then
			util.toast($'No results found under "{input}", try expanding or even narrowing your search query.')
		end
	end
end):setTemporary()

config_root:list_action('Reset', {}, 'Deletes and refreshes the necessary files to their defaults. This action is irreversible.', { 'Theme', 'Header', 'Font', 'Tags', 'Tabs' }, function(index)
	switch index do
		case 1:
			empty_dir(theme_dir)
			reload_textures()
			reload_font()
		break
		case 2:
			empty_dir(header_dir)
			header_hide()
			header_custom()
			header_hide()
		break
		case 3:
			io.remove(theme_dir .. 'Font.spritefont')
			reload_font()
		break
		case 4:
			empty_dir(custom_dir)
			reload_textures()
		break
		case 5:
			empty_dir(tabs_dir)
			reload_textures()
		break
	end
end)
config_root:list_action('Update', {}, '', { 'Headers', 'Themes' }, function(_, menu_name)
	local name = menu_name:lower() .. '.txt'
	download_file(
		'https://raw.githubusercontent.com',
		'/stagnate6628/stand-themerepo/main/' .. name,
		resources_dir .. name
	)
	util.restart_script()
end)
config_root:readonly('Version', SCRIPT_VERSION)