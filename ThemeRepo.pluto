-- Auto Updater from https://github.com/hexarobi/stand-lua-auto-updater
local status, auto_updater = pcall(require, 'auto-updater')
if not status then
  local auto_update_complete = nil
  util.toast('Installing auto-updater...', TOAST_ALL)
  async_http.init('raw.githubusercontent.com', '/hexarobi/stand-lua-auto-updater/main/auto-updater.lua',
      function(result, headers, status_code)
        local function parse_auto_update_result(result, headers, status_code)
          local error_prefix = 'Error downloading auto-updater: '
          if status_code ~= 200 then
            util.toast(error_prefix .. status_code, TOAST_ALL)
            return false
          end
          if not result or result == '' then
            util.toast(error_prefix .. 'Found empty file.', TOAST_ALL)
            return false
          end
          filesystem.mkdir(filesystem.scripts_dir() .. 'lib')
          local file = io.open(filesystem.scripts_dir() .. 'lib\\auto-updater.lua', 'wb')
          if file == nil then
            util.toast(error_prefix .. 'Could not open file for writing.', TOAST_ALL)
            return false
          end
          file:write(result)
          file:close()
          util.toast('Successfully installed auto-updater lib', TOAST_ALL)
          return true
        end
        auto_update_complete = parse_auto_update_result(result, headers, status_code)
      end, function()
        util.toast('Error downloading auto-updater lib. Update failed to download.', TOAST_ALL)
      end)
  async_http.dispatch()
  local i = 1
  while (auto_update_complete == nil and i < 40) do
    util.yield(250)
    i = i + 1
  end
  if auto_update_complete == nil then
    error('Error downloading auto-updater lib. HTTP Request timeout')
  end
  auto_updater = require('auto-updater')
end
if auto_updater == true then
  error('Invalid auto-updater lib. Please delete your Stand/Lua Scripts/lib/auto-updater.lua and try again')
end

local async_http, filesystem, io, util = async_http, filesystem, io, util

local inspect = require 'lib/inspect'
local function log(what)
	util.log(inspect(what))
end

local function get_github_auth() 
	if file := io.open(filesystem.resources_dir() .. 'ThemeRepo\\.github', 'r') then
		local token = file:read('a')
		file:close()
		return token:startswith('ghp_') and token:len() == 40 and token
	end
	return nil
end

local function fetch(host, path, callback)
	local downloading = true
	async_http.init(host, path, function(body, headers, status_code)
		log(headers)
		if status_code == 403 then
			local expire_at = os.date('%d-%m %H:%M', headers['X-Ratelimit-Reset'])
			for i = 1, 5 do
				util.toast($'You are currently being ratelimited by GitHub.\nThis will expire at {expire_at}.')
			end
			util.stop_script()
		elseif status_code == 404 then
			goto continue
		end

		pcall(callback, body, headers, status_code)
		::continue::
	end, function()
		util.toast($'Request to {host}{path} failed to send.')
	end)
	if token := get_github_auth() then
		async_http.add_header('Authorization', 'Bearer ' .. token)
	end
	async_http.dispatch()

	repeat
		util.yield()
	until not downloading
end

local function download_file(host, path, file_path, callback)
	fetch(host, path, function(body, headers, status_code)
		if type(file_path) == 'string' then
			file_path = {file_path}
		end

		for file_path as path do 
			if not filesystem.is_dir(path:match('^(.+)[\\/]')) then
				filesystem.mkdirs(path:match('^(.+)[\\/]'))
			end

			local file = io.open(path, 'wb')
			file:write(body)
			file:close()
		end
	end)
end

local resources_dir = filesystem.resources_dir() .. 'ThemeRepo\\'
local themes_dir = resources_dir .. 'Themes'
local headers_dir = resources_dir .. 'Headers'

for { themes_dir, headers_dir } as path do
	if not filesystem.is_dir(path) then 
		filesystem.mkdir(path)
	end	
end

for { 'themes.txt', 'headers.txt' } as file do
	local path = resources_dir .. file
	if not filesystem.is_regular_file(path) then
		download_file(
			'https://raw.githubusercontent.com', 
			'/stagnate6628/stand-themerepo/main/' .. file,
			path
		)
	end

	local f = io.open(path, 'r')
	local content = f:read('*a'):split('\n')
	f:close()

	menu.my_root():list_select(file, {}, '', content, 1, function() end)
end